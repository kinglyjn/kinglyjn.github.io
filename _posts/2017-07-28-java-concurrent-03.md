---
layout: post
title:  "JAVA内存模型"
desc: "JAVA内存模型"
keywords: "JAVA内存模型,java,kinglyjn,张庆力"
date: 2017-07-28
categories: [Java]
tags: [Java]
icon: fa-coffee
---



> 并发编程中，需要处理两个关键性的问题线程之间如何通信以及线程之间如何同步。
>
> 线程之间的通信方式分为两种：共享内存 和 消息传递。
>
> java的并发采用的是共享内存模型，java线程之间的通信总是隐式的进行，整个通信过程对程序员完全透明。



### java内存模型的抽象结构

* 堆内存：存储共享变量（包括实例域、静态域、数据元素）
* 栈内存：存储方法定义参数、局部变量、异常处理参数等不共享的数据

Java线程之间的通信由java内存模型（简称JMM）来控制，JMM决定一个线程对共享变量的的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在注内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memery），本地内存中存储了该线程以读写共享变量的【副本】。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓存区、寄存器以及其他的硬件和编译器优化。java内存模型抽象示意如下：

```defult

          线程A                                 线程B
            |                                   |
            |                                   |
            |/                                  |/
            本地内存A                            本地内存B	
            [存储共享变量的副本]                   [存储共享变量的副本]
            |                                   |
            |                                   |
            |--------------JMM控制---------------|
            |                                   |
            |                                   |
          ---------------------------------------------
		  					主内存
                        [存储很多共享变量]
          --------------------------------------------- 	
            
```

从上面的示意图来看，线程A如果想要和线程B通信的话，必须经历一下两个步骤：

* 线程A将本地内存A中更新过的共享变量刷新到主内存中
* 线程B到主内存中读取线程A之前已经更新过的共享变量

从整体上来看，这两个步骤实质上是线程A在向线程B发送消息，而这个通信过程必须要经历主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。<br>



### 从源代码到指令序列的重排序

在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。

* 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
* 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
* 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图:

```java
源代码---->编译器优化的重排序---->指令级并行的重排序---->内存系统的重排序---->最终执行的指令序列
```

上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求[Java](http://www.2cto.com/kf/ware/Java/)编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。

JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

<br>

