---
layout: post
title:  "C语言基础（八）- 进制转化和计算机补码"
desc: "C语言基础"
keywords: "C语言基础,C语言,kinglyjn"
date: 2013-02-26
categories: [C]
tags: [c]
icon: fa-cc
---

### 进制转化

* 一个数字的大小本质上都是表示状态数的多少
* 数字的表示可以用不同的进制
* 十进制转r进制：整数部分--除r取余，直至商0，余数倒置即可，小数部分--乘r取整，直至积为0，整数正序排列即可
* 二进制转10进制：8421码

<br>

### 补码的相关知识

在介绍补码之前先来认识其他的一些二进制码：<br>
1、原码：<br>
也叫符号—绝对值码，最高位0表示正、1表示负，其余二进制是该数字的绝对值的二进制位<br>
如-5的原码是10101， 原码简单易懂，但是它加减复杂，存在加减乘除四种运算，增加了CPU的复杂度<br>
还有就是源码制下0的表示不唯一，所以源码在计算机中从来不使用。<br>

2、反码：<br>
对原码每一位取反，在计算机中基本无使用<br>

3、移码：<br>
表示数值平移n位，（n称为移码量），移码主要用于浮点数阶码的存储<br>
<br>

以上为认识补码的相关背景知识。<br>
那么什么是补码呢？为什么要引入补码？<br>

<i style="font-size:12px;">在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。</i><br>

补码的特性：

* 一个整数的原码与其补码相加，和为模
* 对一个整数的补码再求补码，等于该整数自身
* 补码的正零与负零表示方法相同

通过源码求补码：<br>

```
[+73]补 = 01001001
[-73]补 = 100000000 - 01001001 = 10110111

[+1]补 = 00000001
[-1]补 = 100000000 - 00000001 = 11111111

[+127] = 01111111
[-127] = 100000000 - 01111111 = 10000001

综上：
1. 整数的补码与其原码相同
2. 0的补码仍然为0
3. 负数的补码可以通过其正数的原码“取反加一”，并且最高符号位也参与运算得到

扩展：
根据补码的定义，可以证明：
[X]补 + [Y]补 = [X+Y]补
[X]补 - [Y]补 = [X-Y]补
这表明，两个补码加减的结果也是补码，而且在运算时，符号位可同数值部分作为一个整体参加运算，如果符号位有进位则舍弃进位。

计算机中的加减运算：
如：4-6=？
                          0000 0100
+ 0000 0110-->1111 1001-->1111 1010
-----------------------------------
                          1111 1110 (所得结果为补码，符号位为负)-->0000 0001-->0000 0010
故最终结果为 -2

[注] 一个数的补码为（1111 1110），求其数值？
     分析：最高位为1，则该数肯定为负数，并且我们知道“补码的补码就是其对应的非负数值”，求得0000 0010，
     故这个数的数值为 -2。
```
<br>

程序演示：

```cpp
/**
* 计算机二进制运算程序演示
*/ 

# include <stdio.h>
int main() {
    int a = 0;
    short int i = -3;
    int j = -3;
    long int k = -3;
    char m = 'A';
    int n = 0XFFFFFFE1; //11111111111111111111111111100001 //负数最高符号位均补1

    printf("%#X\n",a); //0
    printf("%#X\n",i); //0XFFFFFFFD
    printf("%#X\n",j); //0XFFFFFFFD
    printf("%#X\n",k); //0XFFFFFFFD
    printf("%#X\n",m); //0X41
    printf("%d\n",n);  //-31 
    return 0;
}
```
<br>


