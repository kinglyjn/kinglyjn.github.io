---
layout: post
title:  "Hbase java API（二）"
desc: "Hbase java API（二）"
keywords: "Hbase java API（二）,hbase,kinglyjn"
date: 2017-08-26
categories: [Java]
tags: [java]
icon: fa-coffee
---



### 依赖包(以0.98.6-hadoop2版本为例)

```xml
<dependency>
  	<groupId>org.apache.hbase</groupId>
  	<artifactId>hbase-server</artifactId>
  	<version>0.98.6-hadoop2</version>
</dependency>
<dependency>
  	<groupId>org.apache.hbase</groupId>
  	<artifactId>hbase-client</artifactId>
  	<version>0.98.6-hadoop2</version>
</dependency>
```

<br>



### 必要的配置文件（直接拷贝hadoop和hbase环境的配置文件）

```default
core-site.xml
hdfs-site.xml
hbase-site.xml
log4j.properties
```

<br>



### 测试代码示例

```java
package mainf;
import java.io.IOException;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.CellUtil;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.client.Delete;
import org.apache.hadoop.hbase.client.Get;
import org.apache.hadoop.hbase.client.HTable;
import org.apache.hadoop.hbase.client.Put;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.ResultScanner;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.util.Bytes;
import org.apache.hadoop.io.IOUtils;
import org.junit.Test;

/**
 * CRUD
 * 参数和返回值一般采用 静态常量（封装到HbaseTableContent） 和 Map进行封装
 * @author zhangqingli
 *
 */
public class HbaseOperation {
	public static final Configuration CONF = HBaseConfiguration.create();
	
	/**
	 * getHTableByTableaName
	 */
	public HTable getHTableByTableaName(String tableName) throws IOException {
		return new HTable(CONF, tableName);
	}
	
    /**
     * create table
     */
    @Test
    public void testCreate() throws Exception {
        String tableName = "basic";

        HBaseAdmin hadmin = new HBaseAdmin(CONF);
        if (hadmin.tableExists(tableName)) {
            System.out.println("表已经存在");
            hadmin.close();
            return;
        } else {
            HTableDescriptor tableDesc = 
              		new HTableDescriptor(TableName.valueOf(tableName));
            tableDesc.addFamily(new HColumnDescriptor("info"));
            hadmin.createTable(tableDesc);
            System.out.println("创建表成功");
            hadmin.close();
        }
    }

    /**
     * delete table
     */
    @Test
    public void testDrop() throws Exception {
        String tableName = "basic";

        HBaseAdmin hadmin = new HBaseAdmin(CONF);
        if (!hadmin.tableExists(tableName)) {  
            System.out.println("表不存在");  
            hadmin.close();
            return;
        } else {  
                if (!hadmin.isTableDisabled(tableName)) {
                    hadmin.disableTable(tableName);
                }
                hadmin.deleteTable(tableName);
                System.out.println("表删除成功");  
                hadmin.close();
        }
    }
  
  
	/**
	 * get
	 */
	@Test
	public void testGet() throws IOException {
		//get table
		HTable htable = getHTableByTableaName("user");

		Get get = new Get(Bytes.toBytes("1004"));
		//get.addColumn(Bytes.toBytes("info"), Bytes.toBytes("name"));
		//get.addColumn(Bytes.toBytes("info"), Bytes.toBytes("age"));
		Result result = htable.get(get);
		for (Cell cell : result.rawCells()) {
			String famlyColumn = Bytes.toString(CellUtil.cloneFamily(cell));
			String column = Bytes.toString(CellUtil.cloneQualifier(cell));
			String value = Bytes.toString(CellUtil.cloneValue(cell));
			System.out.println(famlyColumn + ":" + column + " -> " + value);
		}
		
		//close table
		htable.close();
	}
	
	
	/**
	 * scan
	 */
	@Test
	public void testScan() throws IOException {
		HTable htable = getHTableByTableaName("user");
		
		Scan scan = new Scan();
		
		/*
		 * 设置Scan的扫描顺序，默认是正向扫描（false）(version>=0.98)
		 */
		//scan.setReversed(false);
		
		/*
		 * range
		 */
		//scan.setStartRow(Bytes.toBytes("1001")); //包头不包尾
		//scan.setStopRow(Bytes.toBytes("1003"));
		
		/*
		 * setTimeRange
		 */
		//scan.setTimeRange(new Date().getTime(), new Date().getTime());
		
		/*
		 * setTimestamp
		 */
		//scan.setTimeStamp(new Date().getTime());
		
		/*
		 *  addColumn
		 */
		//scan.addColumn(Bytes.toBytes("info"), Bytes.toBytes("name"));
		//scan.addColumn(Bytes.toBytes("info"), Bytes.toBytes("age"));
		
		/*
		 * filter（一般filter查询会比较慢，常用的filter只有PrefixFilter、PageFilter）
		 */
		//scan.setFilter(new PrefixFilter(Bytes.toBytes("100")));
		
		
		/*
		 * 设置是否缓存块，默认true缓存数据块
		 * 我们分内存，缓存和磁盘，三种方式，一般数据的读取为 内存->缓存->磁盘
		 * 当MR的时候为非热点数据，因此不需要缓存
		 */
		//scan.setCacheBlocks(true);
		
		/*
		 * 设置每次从服务器端读取的行数，默认值为-1无限制，
		 * 当设置了setCaching(n)后，我们的server会从regin server上读取出n条数据。
	 	 * 那么client端读取数据的时候会直接从server的缓存中返回，但是如果每次你只需
	 	 * 要读取100条记录，但是设置了setCaching(1000),那么每次都会从region server 
	 	 * 多余的拿出900条记录，这样会让应用的server内存吃不消了比较好的解决方案就是 
	 	 * 设置setCaching(n)为实际需要的记录数。
		 */
		//scan.setCaching(-1); 
		
		/*
		 * 设置获取记录的列个数，默认无限制，也就是返回所有的列 
		 */
		//scan.setBatch(1);
		
		/*
		 * 激活或者禁用raw模式。如果raw模式被激活，Scan将返回 所有已经被打上删除标记
		 * 但尚未被真正删除 的数据。该功能仅用于激活了KEEP_DELETED_ROWS的列族，即列
		 * 族开启了 hcd.setKeepDeletedCells(true),Scan激活raw模式后，就不能指定
		 * 任意的列，否则会报错
		 */
		//scan.setRaw(false);
		
		ResultScanner resultScanner = htable.getScanner(scan);
		for (Result result : resultScanner) {
			System.out.println(Bytes.toString(result.getRow()));
			System.out.println(result);
			System.out.println("-----------");
		}
		
		IOUtils.closeStream(htable);
	}
	
	
	/**
	 * put
	 */
	@Test
	public void testPut() throws IOException {
		HTable htable = getHTableByTableaName("user");
		
		Put put = new Put(Bytes.toBytes("1004"));
		put.add(Bytes.toBytes("info"), Bytes.toBytes("name"), Bytes.toBytes("zhaoliu"));
		put.add(Bytes.toBytes("info"), Bytes.toBytes("age"), Bytes.toBytes(25));
		htable.put(put);
		
		htable.close();
	}
	
	
	/**
	 * delete
	 */
	@Test
	public void testDelete() throws IOException {
		HTable htable = getHTableByTableaName("user");
		
		Delete delete = new Delete(Bytes.toBytes("1002"));
      	//删除最新版本cell
		delete.deleteColumn(Bytes.toBytes("info"), Bytes.toBytes("age")); 
      	//删除所有版本cell
		//delete.deleteColumns(Bytes.toBytes("info"), Bytes.toBytes("age")); 
      	//删除一行记录的所有列，注意javaapi没有deleteAll
		//delete.deleteFamily(Bytes.toBytes("info")); 
		htable.delete(delete);
		
		htable.close();
	}
}
```





