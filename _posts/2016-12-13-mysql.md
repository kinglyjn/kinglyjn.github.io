---
layout: post
title:  "linux环境下mysql5.6的安装、配置、使用及常见问题解决办法"
desc: "linux环境下mysql5.6的安装、配置、使用及常见问题解决办法"
keywords: "mysql,安装配置、使用及常见问题解决办法,ubuntu,linux,kinglyjn,张庆力"
date: 2016-12-13
categories: [Linux]
tags: [Linux]
icon: fa-bookmark-o
---

### 准备工作

本文档是在ubuntu14.04下安装5.6版本的mysql。<br>
1、所用软件：Ubuntu14.04 LTS版<br>
2、建议使用root用户<br>
3、使用服务器地址：192.168.1.236<br>
4、安装mysql5.6.19<br>
5、安装mysql需要的依赖<br>

```shell
apt-get install mysql-client-core-5.6
apt-get install mysql-client-5.6
```
<br>

### 安装mysql

```shell
如果运行如上命令后，在命令行信息最后看到类似
apt-get install mysql-server-5.6
安装过程中输入root的密码即可；
```
<br>

### 常用命令

```shell
验证原有主机是否已安装
这里主要是运行sudo netstat -tap | grep mysql命令查看是否有MySQL的端口，如果不加sudo的话因为权限无法顺利执行：
netstat -tap | grep mysql
如果按照成功，执行上面命令会显示：
tcp        0      0 localhost:mysql         *:*                     LISTEN      6840/mysqld 


启动
# 启动MySQL
$ sudo service mysql start 
# 关闭MySQL
$ sudo service mysql stop
# 重启MySQL
$ sudo service mysql restart
# 其他命令：
$ sudo /etc/init.d/mysql start
$ sudo /etc/init.d/mysql stop
$ sudo /etc/init.d/mysql restart

然后，再次键入命令来检查是否已启动MySQL：
$ netstat -tap | grep mysql
MySQL监听在localhost，说明MySQL已经启动。


登录
使用命令行mysql -u root -p 来登录MySQL：
$ mysql -u root -p

远程登录
$ mysql  -h192.168.1.160 -u root -p
$ mysql  -h192.168.1.160 -P3306 -u root -p


---------[一些常见操作]----------
#显示创建指令
$ show create database test;
$ show create table test.t_user;
#更改数据库的编码方式
$ alter database test CHARACTER SET = utf8;
#查看表、字段、索引
$ show tables from test;
$ show clumns from test.t_user;
$ show indexes from test.t_user;
#重命名--可能导致视图或者存储过程失效
rename table old_table_name to new_table_name;
alter table t_user change old_column_name new_column_name type;
#添加字段
alter table t_stu3 add pwd varchar(255) after name; --或者 first
#删除字段
alter table t_stu3 drop pwd, drop sex;
#修改字段
alter table t_stu3 modify stu_name varchar(20) not null after id;
alter table t_stu3 change stu_name sname varchar(20) not null after id;
#添加索引
alter table t_stu4 add index index_stu_name(stu_name);
alter table t_stu4 add constraint pk_stu4 primary key(id);
alter table t_stu4 add constraint fk_stu4_clazz4 foreign key(clazz_id) references t_clazz4(id) on delete restrict;
alert table t_stu4 add unique(name);
alter table t_stu3 alter column sex set default 3;

#删除索引
alter table t_stu3 drop index index_xxx;
alter table t_stu4 drop foreign key fk_stu4_clazz4;
alter table t_stu3 alter column sex drop default;

#插入记录
insert into t_clazz3(name) values('23班');
insert into t_clazz4 values(default, '23班');
insert into t_clazz4 set name='24班';
insert into t_clazz3(name) select name from t_clazz4;
#更新记录
update t_stu3 set name='keyllo', age=18 where id=1;
#删除记录
delete from t_stu3 where where id=1; --只删除数据
truncate table t_stu3; --除了删除数据，也删除索引等，可能主键id自增也会重置
drop table t_stu3;
---------[END]----------


重启服务
sudo service mysql restart


停止服务
sudo service mysql stop


查看服务状态
sudo service mysql status
```
<br>



### 常见错误解决方案

#### 常见错误1： Can't connect to MySQL server on '10.211.55.5' (61)

我要在本机链接我本机上虚拟机的mysql，我使用mac下的workbench，就就是连接不上，报错信息为：“Can't connect to MySQL server on '10.211.55.5' (61)”，查了好多资料，有一种方法解决了我的问题：

```shell
#第一步：查看3306端口是否开启
# 使用ufw，sudo ufw status或者直接使用命令 netstat -an | grep 3306，如果结果显示类似：
#tcp   0   0 127.0.0.1:3306   0.0.0.0:*     LISTEN
#从结果可以看出3306端口只是在IP 127.0.0.1上监听，所以拒绝了其他IP的访问。

#第二步：修改配置文件
#修改文件 /etc/mysql/my.cnf文件，打开文件，找到下面内容：
    # Instead of skip-networking the default is now to listen only on
    # localhost which is more compatible and is not less secure.
    bind-address = 127.0.0.1
#把上面这一行注释掉或者把127.0.0.1换成合适的IP，建议注释掉。
#重新启动后，重新使用netstat检测：
    netstat -an | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN

#第三步：使用创建的用户登录一下，成功。

#第四部：修改编码方式
> grep 'character' /etc/mysql/my.cnf 
default-character-set=utf8
character-set-server=utf8

#第五步：默认的存储引擎设置为支持外键和事务的存储引擎InnoDB
grep 'default-storage-engine' /etc/mysql/my.cnf 
default-storage-engine=INNODB
#可以查看数据库的存储引擎
show engines;
```
<br>

#### 常见错误二：is not allowed to connect to this MySQL server

ERROR 1130: Host ’192.168.1.3′ is not allowed to connect to this MySQL server这是告诉你没有权限连接指定IP的主机，下面我们来看看解决办法。<br>
处理方法有二个：<br>

1、 授权法<br>

```shell
例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话。
GRANT ALL PRIVILEGES ON *.* TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;

如果你想允许用户myuser从ip为192.168.1.3的主机连接到mysql服务器，并使用mypassword作为密码
GRANT ALL PRIVILEGES ON *.* TO 'root'@'192.168.1.3' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;
GRANT ALL PRIVILEGES ON *.* TO 'root'@'10.10.40.54' IDENTIFIED BY '123456' WITH GRANT OPTION;
```

2、 改表法<br>

```shell
可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 "mysql" 数据库里的 “user” 表里的 “host” 项，从”localhost”改成”%
这个是因为权限的问题，处理方式如下:
shell>mysql --user=root -p
输入密码
mysql>use mysql
mysql>GRANT SELECT,INSERT,UPDATE,DELETE ON [db_name].* TO [username]@[ipadd] identified by '[password]';

[username]:远程登入的使用者代码
[db_name]:表示欲开放给使用者的数据库称
[password]:远程登入的使用者密码
[ipadd]:IP地址或者IP反查后的DNS Name，此例的内容需填入'60-248-32-13.HINET-IP.hinet.net' ，包函上引号(’)
（其实就是在远端服务器上执行，地址填写本地主机的ip地址。）

也可以这样写
mysql -u root -pvmware
mysql>use mysql;
mysql>update user set host = '%' where user = 'root';
mysql>select host, user from user;
```
<br>


#### 常见错误三：cant connect to mysql server 10060

```shell
出现这种现象的原因有两个，一个是当前用户被MySQL服务器拒绝，另外一个原因是3306端口被被防火墙禁掉，无法连接到该端口。解决方法如下：

1.设置远程用户访问权限：
// 任何远程主机都可以访问数据库  
mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%'WITH GRANT OPTION;     
//需要输入次命令使修改生效
mysql> FLUSH PRIVILEGES;      
//退出
mysql> EXIT


2.在iptables中开放3306端口
 #/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT
 #/etc/rc.d/init.d/iptables save  保存：
 # service iptables restart  重启生效
当然除了开放3306端口外，还有一个方法就是关闭防火墙，命令为：
 # service iptables stop  
不过，不推荐这种做法，因为这会引起安全性问题。     
```
<br>



### 修改默认编码为UTF8

```
登录MySQL，进行字符编码查看：
#mysql -u root - p
输入密码
mysql> show variables like ‘character%’ ;  
+————————–+—————————-+ 
| Variable_name | Value | 
+————————–+—————————-+ 
| character_set_client | latin1 | 
| character_set_connection | latin1 | 
| character_set_database | latin1 | 
| character_set_filesystem | binary | 
| character_set_results | latin1 | 
| character_set_server | latin1 | 
| character_set_system | utf8 | 
| character_sets_dir | /usr/share/mysql/charsets/ | 
+————————–+—————————-+ 

在/etc/mysql下有个my.cnf文件，我们修改my.cnf文件
ubuntu@dbserver:~$ grep 'character' /etc/mysql/my.cnf 
[mysqld]  
......
character_set_server=utf8  
collation-server=utf8_general_ci  
......  
  
[client]
......
#设置客户端字符集
default-character-set=utf8  
......

修改完成后，service mysql restart重启mysql服务就生效。注意位置，default-character-set=utf8只能放在[client]下面，否则不能启动MySQL
```

<br>



### mysql 的权限管理

```sql
--mysql涉及到的授权表
select * from mysql.user;
select * from mysql.tables_priv;
select * from mysql.columns_priv;

--显示当前的用户
select user();

--添加超级用户（DBA）
-- *.* 表示是所有的库，所有的表
-- keyllo@localhost表示用户名和允许用户登录使用的ip段
-- identified by 后面是用户登录所需的密码
-- with grant option 表示该用户还能给其他用户赋权
grant all privileges on *.* to keyllo@localhost identified by '123456' with grant option;

--添加普通用户
grant create,create temporary tables,update,execute,select,show view,usage,delete on test.* to keyllo2@localhost  identified by '123456' with grant option;

--使权限立即生效
flush privileges;

--收回用户的某些权限
revoke select,update on test.* from keyllo2@localhost;

--删除一个用户
drop user keyllo2@localhost;

--查看一个用户有哪些权限
show grants for root@localhost;
```

<br>



### mysql数据库的备份和恢复

```sql
-- 备份
mysqldump -hlocalhost -uroot -pxxx test > ~/test/mysql_dump/dbname_20161213.dump
mysqldump -hlocalhost -uroot -pxxx test t_user > ~/test/mysql_dump/dbname_20161213.dump
mysqldump -hlocalhost -uroot -p --all-databases > xxx/xxx.dump

-- 还原
mysql -hlocalhost -uroot -pxxx dbname < ~/test/mysql_dump/dbname_20161213.dump
mysql -hlocalhost -uroot -pxxx dbname < ../exe.sql
mysql -hlocalhost -uroot -p < xxx/all_databases.dump
mysql -hlocalhost -uroot -pxxx dbname -e "select * from t_user"
mysql -hlocalhost -uroot -p dbname -e "select * from t_user"

-- 通过可视化工具进行数据库的备份和恢复(导出和导入)
mysql_workbench、navicat、dbeaver、sqlyog
```

<br>



### mysql 主备配置：

MySQL支持三种复制方式：基于行(Row)的复制、基于语句(Statement)的复制和混合类型(Mixed)的复制。

基于语句的复制早在3.23版本中就存在，而基于行的复制方式在5.1版本中才被加进来。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。

混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。

复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但出于备份或及时从崩溃中恢复的目的，这点开销也是必要的。除此之外，每个备库也会对主库增加一些负载（例如网络I/O开销），尤其当备库请求从主库读取旧的二进制日志文件时，可能会造成更高的I/O开销。另外锁竞争也可能阻碍事务的提交。最后，如果是从一个高吞吐量的主库上复制到多个备库，唤醒多个复制线程发送事件的开销将会累加。

<br>

权限配置

```sql
mysql>GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'root@'%' IDENTIFIED BY 'root';
```

复制账户事实上只需要有主库上的REPLICATION SLAVE权限，并不一定需要每一端服务器都有REPLICATION CLIENT权限，那么为什么我们要把这两种权限给主/备库都赋予呢？这有两个原因： 

1. 用来监控和管理复制的账号需要REPLICATION CLIENT权限，并且针对这两种目的使用同一个账号更加容易。 
2. 如果在主库上建立了账号，然后从主库将数据克隆到备库上时，备库也就设置好了——变成主库所需要的配置。这样后续有需要可以方便地交换主备库的角色。 
   如果无脑式配置可以：

<br>

主备库配置

关停Master服务器，将Master中的数据拷贝到B服务器中，使得Master和slave中的数据同步，并且确保在全部设置操作结束前，禁止在Master和slave服务器中进行写操作，使得两数据库中的数据一定要相同！ 
备注：文中采用的案例中主备库都有5个schema：

```sql
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| canal_test         |
| mysql              |
| performance_schema |
| test               |
+--------------------+
```

主库的/etc/my.cnf配置(主机host:10.198.197.73)

```shell
[mysqld]
log-bin=mysql-bin
server-id=1
```

备库上也需要在/ect/my.cnf进行配置(备机host:10.198.197.60)

```sql
[mysqld]
log-bin=mysql-bin
server-id=2
relay_log=mysql-relay-bin
log_slave_updates=1
read_only=1
```

server_id 是必须的，而且唯一。slave没有必要开启二进制日志，但是在一些情况下，必须设置，例如，如果slave为其它slave的master，必须设置 bin_log。在这里，我们开启了二进制日志，而且显示的命名(默认名称为hostname，但是，如果hostname改变则会出现问题)。

relay_log配置中继日志，log_slave_updates表示slave将复制事件写进自己的二进制日志(后面会看到它的用处)。

有 些人开启了slave的二进制日志，却没有设置log_slave_updates，然后查看slave的数据是否改变，这是一种错误的配置。所以，尽量 使用read_only，它防止改变数据(除了特殊的线程)。但是，read_only并是很实用，特别是那些需要在slave上创建表的应用。

<br>



启动slave

接下来就是让slave连接master，并开始重做master二进制日志中的事件。你不应该用配置文件进行该操作，而应该使用CHANGE MASTER TO语句，该语句可以完全取代对配置文件的修改，而且它可以为slave指定不同的master，而不需要停止服务器。如下：

```sql
mysql> CHANGE MASTER TO 
    -> MASTER_HOST='10.198.197.73',
    -> MASTER_USER='root',
    -> MASTER_PASSWORD='root',
    -> MASTER_LOG_FILE='mysql-bin.000004',
    -> MASTER_LOG_POS=0;
```

MASTER_LOG_POS的值为0，因为它是日志的开始位置。 
你可以用SHOW SLAVE STATUS语句查看slave的设置是否正确：

```sql
mysql> show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: 
                  Master_Host: 10.198.197.73
                  Master_User: root
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000004
          Read_Master_Log_Pos: 4
               Relay_Log_File: mysql-relay-bin.000001
                Relay_Log_Pos: 4
        Relay_Master_Log_File: mysql-bin.000004
             Slave_IO_Running: No
            Slave_SQL_Running: No
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 4
              Relay_Log_Space: 107
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: NULL
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 0
1 row in set (0.00 sec)
```

Slave_IO_State, Slave_IO_Running, 和Slave_SQL_Running是No表明slave还没有开始复制过程。日志的位置为4而不是0，这是因为0只是日志文件的开始位置，并不是日志位置。实际上，MySQL知道的第一个事件的位置是4。

为了开始复制，你可以运行：

```sql
mysql> start slave;
```

运行show slave status查看输出结果：

```shell
mysql> show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 10.198.197.73
                  Master_User: root
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000004
          Read_Master_Log_Pos: 2395
               Relay_Log_File: mysql-relay-bin.000002
                Relay_Log_Pos: 253
        Relay_Master_Log_File: mysql-bin.000004
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 2395
              Relay_Log_Space: 409
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 1
```

在这里主要是看:

```shell
    				Slave_IO_Running=Yes
                    Slave_SQL_Running=Yes
```

slave的I/O和SQL线程都已经开始运行，而且Seconds_Behind_Master不再是NULL。日志的位置增加了，意味着一些事件被获取并执行了。如果你在master上进行修改，你可以在slave上看到各种日志文件的位置的变化，同样，你也可以看到数据库中数据的变化。

如果此时Slave_SQL_Running=No，可以参考下下面的方法进行解决：

**解决方案1** 
程序可能在slave上进行了写操作，也可能是slave机器重启后事务回滚造成的。 
如果是事务回滚造成的，可以：

```sql
mysql> slave stop;
Query OK, 0 rows affected (0.00 sec)

mysql> set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;
Query OK, 0 rows affected (0.00 sec)

mysql> slave start;
Query OK, 0 rows affected (0.00 sec)
```

最后通过show slave status进行查看。

**解决方案2** 

首先停掉slave服务：

```sql
mysql> slave stop;
```

到master上查看主机状态：

```sql
mysql> show master status;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000004 |     2395 |              |                  |
+------------------+----------+--------------+------------------+
1 row in set (0.00 sec)
```

然后到slave服务器上执行手动同步：

```sql
mysql> change master to 
    -> master_host='10.198.197.73',
    -> master_user='root',
    -> master_password='root',
    -> master_port=3306,
    -> master_log_file='mysql-bin.000004',
    -> master_log_pos=2395;
mysql> slave start;
```

<br>



你可查看master和slave上线程的状态。在master上，你可以看到slave的I/O线程创建的连接(**Binlog Dump**)： 
在master上输入show processlist\G;

```sql
mysql> show processlist\G
*************************** 1. row ***************************
     Id: 30
   User: root
   Host: localhost
     db: canal_test
Command: Query
   Time: 0
  State: NULL
   Info: show processlist
*************************** 2. row ***************************
     Id: 33
   User: root
   Host: zhuzhonghua1-c6uu8.sh.vclound.com:49005
     db: NULL
Command: Binlog Dump
   Time: 33
  State: Master has sent all binlog to slave; waiting for binlog to be updated
   Info: NULL
```

同样，在备库也可以看到两个线程，一个是I/O线程，一个是SQL线程（**Connect**）：

```shell
mysql> show processlist\G
*************************** 1. row ***************************
     Id: 3
   User: root
   Host: 10.198.197.60:62159
     db: NULL
Command: Binlog Dump
   Time: 67811
  State: Master has sent all binlog to slave; waiting for binlog to be updated
   Info: NULL
*************************** 2. row ***************************
     Id: 14
   User: root
   Host: localhost
     db: canal_test
Command: Query
   Time: 0
  State: NULL
   Info: show processlist
*************************** 3. row ***************************
     Id: 19
   User: root
   Host: 10.198.197.60:62390
     db: NULL
Command: Sleep
   Time: 187
  State: 
   Info: NULL
*************************** 4. row ***************************
     Id: 20
   User: system user
   Host: 
     db: NULL
Command: Connect
   Time: 64
  State: Waiting for master to send event
   Info: NULL
*************************** 5. row ***************************
     Id: 21
   User: system user
   Host: 
     db: NULL
Command: Connect
   Time: 64
  State: Slave has read all relay log; waiting for the slave I/O thread to update it
   Info: NULL
```

<br>

案例测试

在master上的Schema Name: canal_test中有一个perosn的表，表结构如下：

```sql
mysql> describe person;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int(11)      | NO   | PRI | NULL    |       |
| name  | varchar(100) | YES  |     | NULL    |       |
| age   | int(11)      | YES  |     | NULL    |       |
| sex   | char(1)      | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
```

表中有一条记录：

```sql
mysql> select * from person;
+----+------+------+------+
| id | name | age  | sex  |
+----+------+------+------+
|  2 | zzh2 |   21 | m    |
+----+------+------+------+
```

（注意此时slave中的数据是一样的） 
往master上插入一条数据，之后查看：

```sql
mysql> insert into person values(1,'zzh',22,'m');
mysql> select * from person;
+----+------+------+------+
| id | name | age  | sex  |
+----+------+------+------+
|  1 | zzh  |   22 | m    |
|  2 | zzh2 |   21 | m    |
+----+------+------+------+
```

可以看到master中成功插入了一条数据，之后可以同样在slave中输入select * from person来查看，如果结果master和slave相同，那么恭喜你主备复制已经成功了。





